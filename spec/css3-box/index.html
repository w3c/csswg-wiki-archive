<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CSS Box Module Level 3 - CSS Working Group Wiki (Archive)</title>
<style>
*, *::before, *::after { box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  max-width: 900px; margin: 0 auto; padding: 1.5em 1em; line-height: 1.6;
  color: #1f2328; background: #fff;
}
.archive-banner {
  background: #fff8c5; border: 1px solid #d4a72c; border-radius: 6px;
  padding: 0.75em 1em; margin-bottom: 1.5em; font-size: 0.9em;
}
.archive-banner strong { color: #6e5600; }
header { border-bottom: 1px solid #d1d5db; padding-bottom: 1em; margin-bottom: 1.5em; }
header h1 { margin: 0; font-size: 1.25em; }
header h1 a { color: #0366d6; text-decoration: none; }
header h1 a:hover { text-decoration: underline; }
nav { margin-top: 0.5em; font-size: 0.9em; }
nav a { color: #656d76; text-decoration: none; margin-right: 1em; }
nav a:hover { color: #0366d6; }
h1, h2, h3, h4 { color: #1f2328; margin-top: 1.5em; }
h1:first-child { margin-top: 0; }
a { color: #0366d6; }
code { background: #f6f8fa; padding: 0.15em 0.3em; border-radius: 3px; font-size: 0.9em; }
pre { background: #f6f8fa; padding: 1em; overflow: auto; border-radius: 6px; }
pre code { background: none; padding: 0; }
table { border-collapse: collapse; margin: 1em 0; }
th, td { border: 1px solid #d1d5db; padding: 0.4em 0.8em; }
th { background: #f6f8fa; }
img { max-width: 100%; }
.breadcrumb { font-size: 0.85em; color: #656d76; margin-bottom: 1em; }
.breadcrumb a { color: #656d76; }
ul, ol { padding-left: 1.5em; }
li { margin: 0.25em 0; }
.plugin_note { background: #f0f4f8; border-left: 4px solid #0366d6; padding: 0.75em 1em; margin: 1em 0; border-radius: 3px; }
abbr { text-decoration: underline dotted; cursor: help; }
@media (prefers-color-scheme: dark) {
  body { background: #0d1117; color: #e6edf3; }
  .archive-banner { background: #3d2e00; border-color: #6e5600; }
  .archive-banner strong { color: #f0c000; }
  header { border-bottom-color: #30363d; }
  header h1 a { color: #58a6ff; }
  nav a { color: #8b949e; }
  nav a:hover { color: #58a6ff; }
  h1, h2, h3, h4 { color: #e6edf3; }
  a { color: #58a6ff; }
  code, pre { background: #161b22; }
  th, td { border-color: #30363d; }
  th { background: #161b22; }
  .breadcrumb, .breadcrumb a { color: #8b949e; }
  .plugin_note { background: #161b22; border-color: #58a6ff; }
}
</style>
</head>
<body>
<div class="archive-banner">
<strong>Archive Notice:</strong> This is a read-only archive of the CSS Working Group Wiki.
The original wiki was hosted at wiki.csswg.org.
</div>
<header>
<h1><a href="/">CSS Working Group Wiki</a></h1>
<nav>
<a href="/">Home</a>
<a href="/spec/">Specs</a>
<a href="/ideas/">Ideas</a>
<a href="/test/">Testing</a>
<a href="/wiki/">About</a>
</nav>
</header>
<div class="breadcrumb"><a href="/">Home</a> / <a href="/spec/">spec</a> / css3-box</div>
<main>
<!-- TOC START -->
<div id="dw__toc" class="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><a href="#css-box-module-level-3">CSS Box Module Level 3</a></li>
<li class="level1"><a href="#general-problems-to-solve">General Problems to Solve</a><ul class="toc">
<li class="level2"><a href="#property-transfer-from-elements-to-boxes">Property transfer from elements to boxes</a></li>
<li class="level2"><a href="#containing-blocks">Containing blocks</a></li>
<li class="level2"><a href="#anonymous-boxes">Anonymous boxes</a></li>
<li class="level2"><a href="#flow-roots-flows-and-formatting-contexts">Flow roots, flows and formatting contexts</a></li>
</ul>
</li>
<li class="level1"><a href="#spec-issues">Spec Issues</a></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 id="css-box-module-level-3">CSS Box Module Level 3</h1>
<p>
The goals of the CSS3 Box <abbr title="specification">spec</abbr> are to rewrite the CSS2.1 box model such that it is:
</p>
<ul>
<li class="level1">more understandable (better organization and clearer prose)</li>
<li class="level1">more precise (defines vague or missing concepts from CSS2.1, defines undefined concepts from CSS2.1)</li>
<li class="level1">generalized to handle vertical text (See <abbr title="Cascading Style Sheets">CSS</abbr> Writing Modes module)</li>
</ul>

<p>
This page is to track specifically the remaining work on the <abbr title="Cascading Style Sheets">CSS</abbr> Box module. Please post issues to <a href="http://lists.w3.org/Archives/Public/www-style/" title="http://lists.w3.org/Archives/Public/www-style/" rel="noopener">www-style</a> first for discussion, then add a summary and a link to the discussion and/or any key messages below.
</p><h1 id="general-problems-to-solve">General Problems to Solve</h1>
<p>
This section is for describing general problems that the <abbr title="Cascading Style Sheets">CSS</abbr> Box module must solve, e.g. concepts that need defining or refining, or <abbr title="specification">spec</abbr> areas that should be rewritten to improve clarity.
</p><h2 id="property-transfer-from-elements-to-boxes">Property transfer from elements to boxes</h2>
<p>
CSS21 is clear that properties belong to elements, not boxes, but they cause boxes to be have in certain ways.
</p>

<p>
In reality, though, everyone talks about properties on boxes, and so the css3-box <abbr title="specification">spec</abbr> currently says that “we refer interchangeably to “the P property of an element” and “the P property of a box” (both of which actually mean “the value of property P of…”), unless it is important to distinguish the box and the element, e.g., because the element has several boxes and they don&#039;t all have the same value for the property”.  Unfortunately this doesn&#039;t really work, though, because it&#039;s necessary (or at least very desirable, editorially) to be able to be able to identify boxes by their properties, and that&#039;s not possible unless there&#039;s a clearly defined way of transferring properties from an element to its boxes in the case that an element generates multiple boxes.
</p>

<p>
A better approach is to formalize the use of properties on boxes.  Current thinking:
</p>
<ul>
<li class="level1">Every property which can be set on an element also exists for the box.  Need to exclude the &#039;display&#039; property though, since it doesn&#039;t make sense to talk about a box with display:table (the wrapper box is actually a block or inline-block box, and the table box is block-level with some undefined internal display type); also, flex items are flex-level but the display value of elements which generate them is &#039;block&#039;, so there&#039;s no good display value to associate to the box.</li>
<li class="level1">Just as for elements, some or all of any given property&#039;s values might have no effect on a given box.</li>
<li class="level1">The concept of specified value doesn&#039;t make sense for boxes.  But there are computed, used and actual values just as for elements.</li>
<li class="level1">For each inheritable property that is set on a box, the computed, used or actual value is the same as that for the element to which the box belongs.  That is, elements transfer values of their inheritable properties to the boxes which they generate.  (Unless otherwise specified?  Will there ever be a situation in which an inheritable property on an element which generates multiple boxes gets transferred unequally to those boxes?  I can&#039;t imagine one right now.)</li>
<li class="level1 node">For non-inheritable properties, except when otherwise specified:<ul>
<li class="level2">for principal boxes, the same is true; property values come straight from the element</li>
<li class="level2">for non-principal boxes, the initial value is used as the computed, used and actual value.  (This assumes that a property&#039;s initial value is always a valid used and actual value, and that it doesn&#039;t get transformed when moving from computed to used or from used to actual… which I /think/ is true but is not actually specified anywhere.)</li>
</ul>
</li>
</ul>

<p>
NOTE: check out css3-page where properties are assigned from page context and margin context to boxes; need to align
</p>

<p>
NOTE: how does this work for box fragments?
</p><h2 id="containing-blocks">Containing blocks</h2>
<p>
We have seen frequent cases of <abbr title="specification">spec</abbr> authors using incorrect terminology or awkward constructions when referring to containing blocks, due to the lack of clarity and suitable hooks in CSS21:
</p>
<ul>
<li class="level1">“each element that is a containing block for the given element”</li>
</ul>

<p>
Problem: a containing block is a rectangle, not an element or box <br/>

Problem: a containing block is associated to a box, not to an element <br/>

Problem: a containing block is established by a box, not by an element
</p>
<ul>
<li class="level1">“Some values of these properties result in the creation of a containing block”</li>
<li class="level1">“Note that such an element is always a containing block.”</li>
</ul>

<p>
Problem: not every rectangle that could <em>potentially</em> be a containing block for some box is actually a containing block for an actual box in the formatting structure
</p>
<ul>
<li class="level1">“The containing block of an element with &#039;position: absolute&#039; is determined as specified in <abbr title="Cascading Style Sheets">CSS</abbr> 2.1, except that an ancestor element with &#039;transform&#039; other than &#039;none&#039; is treated the same as one with a &#039;position&#039; of &#039;absolute&#039;, &#039;fixed&#039;, or &#039;relative&#039;.”</li>
</ul>

<p>
Problem: difficulty in inserting new rules to modify how the containing block of a box with particular properties is determined
</p>
<ul>
<li class="level1">“Flex containers form a containing block for their contents exactly like block containers do”</li>
<li class="level1">“Column boxes act as the containing block for their content. That is, column boxes behave like block-level, table cell, and inline-block boxes as per <abbr title="Cascading Style Sheets">CSS</abbr> 2.1, section 10.1, item 2 [CSS21]. However, column boxes do not establish containing blocks for elements with ‘position: fixed’ or ‘position: absolute’.”</li>
</ul>

<p>
Problem: difficulty in restricting attention to only those boxes for whom the container will establish the containing block <br/>

Problem: difficulty in removing boxes from the set of potential containing block–establishing boxes for a given kind of box.
</p>

<p>
Note: need to incorporate extensions specified in the positioning <abbr title="specification">spec</abbr>
</p><h2 id="anonymous-boxes">Anonymous boxes</h2>
<p>
What, really, is an anonymous box?  There currently seem to be two rather different interpretations:
</p>
<ul>
<li class="level1">a “fix-up” box, ie a box inserted into the formatting structure in order to ensure that content which participates in a given formatting context is grouped in such a way that it obeys the requirements of that formatting context</li>
<li class="level1">a box that cannot be addressed with <abbr title="Cascading Style Sheets">CSS</abbr> selectors</li>
</ul><h4 id="potential-candidates-for-anonymous-status">Potential candidates for &quot;anonymous&quot; status</h4>
<ul>
<li class="level1 node">obvious fix-up boxes:<ul>
<li class="level2">block boxes and inline boxes generated to ensure that block container boxes contain no “loose” content</li>
<li class="level2">boxes generated to ensure a sensible table structure in a table formatting context</li>
<li class="level2">flex-item boxes generated to group “loose” text in a flex formatting context</li>
<li class="level2">grid-item boxes generated to group “loose” text in a grid formatting context</li>
</ul>
</li>
<li class="level1 node">boxes which are necessarily generated for an element (depending on its property values) irrespective of its content:<ul>
<li class="level2">marker box of a list item</li>
<li class="level2">table wrapper box / table box of a table element</li>
<li class="level2">column box(es) of a multicol element</li>
<li class="level2">ruby boxes (?)</li>
</ul>
</li>
<li class="level1 node">other:<ul>
<li class="level2">region flow content box</li>
</ul>
</li>
</ul><h4 id="relevant-quotes">Relevant quotes</h4>
<p>
From CSS21:
</p>
<ul>
<li class="level1">“since anonymous boxes are not part of the document tree, they are not counted when calculating the first child.” (:first-child pseudo-class)</li>
<li class="level1">“inheritance follows the document tree and is not intercepted by anonymous boxes”</li>
<li class="level1">“The properties of anonymous boxes are inherited from the enclosing non-anonymous box. Non-inherited properties have their initial value.”</li>
<li class="level1">“Anonymous block boxes are ignored when resolving percentage values that would refer to it: the closest non-anonymous ancestor box is used instead. For example, if the child of the anonymous block box inside the DIV above needs to know the height of its containing block to resolve a percentage height, then it will use the height of the containing block formed by the DIV, not of the anonymous block box.”</li>
<li class="level1">“The latter are called anonymous inline boxes, because they do not have an associated inline-level element”</li>
<li class="level1">“anonymous inline boxes inherit inheritable properties from their block parent box. Non-inherited properties have their initial value.”</li>
</ul>

<p>
From css3-images:
</p>
<ul>
<li class="level1">“Objects inserted via the CSS2.1 ‘content’ property are anonymous replaced elements, and are sized the same way. [CSS21] Note that such anonymous elements have all their non-inherited properties (including ‘width’, ‘height’, etc.) set to their initial values.”</li>
</ul><h4 id="observations">Observations</h4>
<ul>
<li class="level1">The inheritance mechanism works on document tree elements, not psuedo-elements or boxes, and hence the fact that it ignores certain boxes is obvious, and doesn&#039;t even need to be stated in CSS21.  This fact is a red herring when it comes to defining anonymous boxes.</li>
<li class="level1">That an anonymous box can&#039;t be selected (eg by pseudo-elements) seems to be a design pattern rather than part of the definition of anonymous box…</li>
<li class="level1">…and even if a box can&#039;t be selected right now, it may well become possible to select it in future using a pseudo-element.</li>
</ul><h4 id="current-thinking">Current thinking</h4>
<p>
Technically, I think it&#039;s unnecessary to identify “anonymous boxes” on the basis of how properties are distributed.  Properties are set on elements, and elements generate boxes based on its properties and on the formatting context in which its contents participate.  How an element imparts its properties to the boxes that it generates is the business of that element, and I don&#039;t see that we need a special term to describe a box whose property values all arise in some particular way.  For example, I see no difference between the way that a table element distributes its property values between the wrapper box and the table box and the way that a block element distributes its properties to a so-called anonymous box; inheritable properties are inherited down the box tree (although <abbr title="Cascading Style Sheets">CSS</abbr> doesn&#039;t state that explicitly anywhere) and non-inheritable properties get their values from somewhere as defined by the element “type”.
</p>

<p>
If the definition of principal box is modified so that an inline element generates a principal box (possibly fragmented across multiple line boxes), then perhaps we can define an anonymous box to be any box which is not a principal box.  In that case, “derived box” might be a better term since such a box might not be anonymous in the sense that there may well exist a selector which can directly address some properties of that box (eg table element selector which addresses the table box, list item selector which addresses the marker box or even a ::marker pseudo-element).
</p>

<p>
Editorially, it&#039;s be helpful to have a name for “fix-up boxes” introduced into the formatting structure in order to ensure that the rules of each formatting context are met.  Perhaps the term “anonymous box” could be used for this purpose?  Need to define fix-up box: perhaps say that it&#039;s a box which cannot be distinguished by its property values and characteristics from a box generated by some hypothetical document element.  Implications: column boxes and probably certain ruby boxes would *not* be anonymous, since no hypothetical document element could create them.  A misparented table cell can result in the creation of an anonymous/fix-up table wrapper box, but is it reasonable to call the table box anonymous?  Is the table box a fix-up, really, or is the wrapper box the fix up and the table box the natural consequence of the wrapper box?
</p>

<p>
My preferred approach is currently to equate anonymous boxes with “fix-up boxes” as just described.
</p><h2 id="flow-roots-flows-and-formatting-contexts">Flow roots, flows and formatting contexts</h2>
<p>
<abbr title="Cascading Style Sheets">CSS</abbr> has “normal flow”, “in-flow” and “out of flow”, but never really explains what the/a normal flow is.  It&#039;s reasonably clear about what a flow is though.
</p><h4 id="relevant-quotes-for-flow">Relevant quotes for flow</h4>
<p>
From CSS21:
</p>
<ul>
<li class="level1">“normal flow includes block formatting of block-level boxes, inline formatting of inline-level boxes”</li>
<li class="level1">“An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow.”</li>
<li class="level1">“The flow of an element A is the set consisting of A and all in-flow elements whose nearest out-of-flow ancestor is A.” …hence the flow of an in-flow element is the singleton consisting of itself… which seems nonsensical; presumably this sentence is assuming that A is an out-of-flow element.</li>
<li class="level1">“Boxes in the normal flow belong to a formatting context, which in <abbr title="Cascading Style Sheets">CSS</abbr> 2.1 may be table, block or inline. In future levels of <abbr title="Cascading Style Sheets">CSS</abbr>, other types of formatting context will be introduced. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.” (wording taken from errata)</li>
<li class="level1">“The baseline of an &#039;inline-block&#039; is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or […]”</li>
<li class="level1">“User Agents must apply these properties to block-level elements in the normal flow of the root element” (&#039;page-break-*&#039;)</li>
</ul>

<p>
From css3-break:
</p>
<ul>
<li class="level1">“User Agents must apply these [&#039;break-*&#039;] properties to boxes in the normal flow of the fragmentation root. User agents should also apply these properties to floated boxes whose containing block is in the normal flow of the root fragmented element.”</li>
</ul>

<p>
Fros css3-regions:
</p>
<ul>
<li class="level1">“A named flow is the ordered sequence of elements associated with a flow with a given identifier. Elements in a named flow are ordered according to the document order.”</li>
<li class="level1">Any element, &#039;flow-into:&lt;ident&gt;&#039;: “The element is taken out of its parent&#039;s flow and placed into the flow with the name ‘&lt;ident&gt;’. The element is said to have a specified flow.”</li>
<li class="level1">“If an element has the same specified flow as one of its ancestors, it becomes a sibling of its ancestor for the purpose of layout in the region chain laying out content from that flow.”</li>
<li class="level1"></li>
</ul>

<p>
[Note: css3-page 9.4 (Allowed page breaks) says: “In the normal flow, page breaks may occur at the following places”.  What does this mean?  Does this indicate that a nested flow root may be fragmented if its its in-flow content has page break opportunities as specified?  Or is it trying to say that page break opportunities only exist in the outermost flow (whatever that actually is)?]
</p>

<p>
[Note: according to CSS21 9.3, the root element is out of flow.  Is this correct?  Surely it participates in the block formatting context established by the initial containing block.]
</p><h4 id="relevant-quotes-for-formatting-contexts">Relevant quotes for formatting contexts</h4>
<p>
From flexbox:
</p>
<ul>
<li class="level1">“A flex container establishes a new flex formatting context for its contents. This is the same as establishing a block formatting context, except that flex layout is used instead of block layout: floats do not intrude into the flex container, and the flex container&#039;s margins do not collapse with the margins of its contents.”</li>
</ul>

<p>
From multicol:
</p>
<ul>
<li class="level1">“A multi-column element establishes a new block formatting context, as per <abbr title="Cascading Style Sheets">CSS</abbr> 2.1 section 9.4.1.  Example: A top margin set on the first child element of a multicol element will not collapse with the margins of the multicol element.”</li>
<li class="level1">The &#039;all&#039; value of &#039;column-span&#039;: “The element spans across all columns of the nearest multicol ancestor in the same block formatting context. […] The element establishes a new block formatting context.”</li>
</ul>

<p>
From exclusions:
</p>
<ul>
<li class="level1">“An exclusion element [block-level element which is not a float and generates an exclusion box (ie ‘wrap-flow’ property&#039;s computed value is not ‘auto’)] establishes a new block formatting context”</li>
</ul>

<p>
From writing-modes:
</p>
<ul>
<li class="level1">“If an element has a different block flow direction than its containing block […, and] the element is a block container, then it establishes a new block formatting context.”</li>
</ul>

<p>
From regions:
</p>
<ul>
<li class="level1">“<abbr title="Cascading Style Sheets">CSS</abbr> Regions establish a new block formatting Context.”</li>
</ul><h4 id="current-thinking1">Current thinking</h4>
<p>
Formatting contexts are established by (possibly anonymous) boxes which may or may not be flow roots, whilst a flow root necessarily establishes a formatting context of some kind, depending on the box&#039;s properties.
</p>

<p>
A flow root is roughly a box whose normal flow is rendered in a location that&#039;s out-of-sync with the normal flow content that surrounds the flow root&#039;s box in the box tree.  I&#039;m not yet clear whether its even necessary to care about the concept of flow root.  The more obviously important concept is that of formatting context.
</p>
<ul>
<li class="level1">Regions, floats and abspos boxes are flow roots.</li>
<li class="level1">Neither column boxes, page boxes nor align boxes are inherently flow roots, but they do establish new formatting contexts.</li>
<li class="level1">(The “align box” type exists merely to artifically establish a new block formatting context.  Its name desperately needs changing.)</li>
<li class="level1">Boxes whose used value of ‘overflow’ is not ‘visible’, table wrapper boxes, table cells, inline blocks, transform boxes and boxes whose directionality is orthogonal to their parent are <em>probably</em> not flow roots, but they do establish new formatting contexts.</li>
<li class="level1">A ‘child-align’ box is neither a flow root nor inherently establishes a new formatting context.</li>
</ul>

<p>
Column boxes establish column formatting contexts which are currently identical in behaviour to block formatting contexts.
(In future, column formatting contexts might allow the overflow of a float from a previous column to affect the block formatting of the column in which the overflow sits.  Perhaps &#039;clear&#039; will react to that float overflow too.)
</p>

<p>
Recall that the scope of float behaviour and clearance behaviour is restricted to the block formatting context in which the float and clearing element participates.
</p>

<p>
Interesting note: no flow root can ever establish an inline formatting context, because inline formatting contexts can only exist inside of another non-inline formatting context.  This is because inline formatting contexts may contain floats, and how those floats behave depends on the outer formatting context.  If the outer formatting context is a BFC then the float floats, though it&#039;s not clear where its box belongs in the box tree.  If the outer formatting context is something else (and no examples exist of this yet in <abbr title="Cascading Style Sheets">CSS</abbr>) then whether and how the float floats is up to that formatting context.
</p>

<p>
Random note: block formatting contexts are not concerned merely with the formatting of block-level elements.  They&#039;re also concerned with the formatting of floats and of list marker boxes.  Of course, if such things are defined to be block-level then semantically there&#039;s no issue… but the description of block-level formatting needs to make reference to these things, even if it leaves the details to other specs.
</p>

<p>
Random note: each formatting context needs to explain how to resolve the battle between a child&#039;s intrinsic size and extrinsic size.
</p><h1 id="spec-issues">Spec Issues</h1>
<p>
This section is for listing errors in the <abbr title="specification">spec</abbr> and mismatches against CSS2.1.
</p>
</main>
</body>
</html>
