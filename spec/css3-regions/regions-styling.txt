==== Region Styling: Proposed alternate syntax ====

== Problem Description ==

With regions, element (or pseudo-element) boxes are often broken into multiple pieces that are laid out in different regions. 
For example, it is possible to move an element and its generated box with width:100% to a flow and 
layout the flow between two regions, one of width 500px and one of width 200px. In that situation,
the specified width for the element is 100% and its used value for the portion laid out in the first 
region is 500px and 200px for the second region.

So there is a notion of per-fragment used style.

In addition, regions have a notion of style that applies only to the fragments of an element that
falls into a particular region. A way to think about this is to consider that the selectors in the 
@region style rules apply to the pseudo-elements representing the fragment of the element that falls in
a particular region.

For example:

<code>
@region #regionA {
    h2 {
        color: red;
    }
}
</code>

can be interpreted as specifying an additional property for the:

<code>h2::in-region(regionA)</code> pseudo-element, where the '::in-region(<region-name>)' 
pseudo-element selects the fragment of 'h2' that fits into '<region-name>'.

This assumes that we are able to identify regions uniquely and uniformly (i.e., no matter whether 
they are elements or not). Note the pseudo-element syntax uses an identifier and the @region rule uses an id selector).

For the sake of the discussion, we can assume we are using the 'region-name' property to set a region identity. For example, if 
the region was a '::before' pseudo-element:

<code>
#myElement::before {
    region-name: regionA;
}
</code>

If we follow that model, the used style for the content falling into a particular region could be retrieved as:

<code>
window.getComputedStyle(elementInFlow,'::in-region(regionA)');
</code>

The issues with the current @region rule are:

  - requires additional DOM method
  - is not consistent with ::first-line and other existing pseudo-elements which select a fragment of an element
  - inconsistency between the CSS syntax (@region) and the getComputedStyle calls (use '::in-region' or equivalent)

=== Proposal ===

Modify the region styling syntax to be consistent with existing 'fragment' selectors:

  - Add a 'region-name' property to assign a name to a region
  - Introduce the '::in-region(<region-name>)' pseudo-element
  - use the pseudo-element instead of the @region rule and use that pseudo-element to access the used style with getComputedStyle.


=== Open questions ===

  * Can we chain pseudo-elements? For example, can we do the following:

<code>
window.getComputedStyle(elem, "::before::in-region(regionA)");
</code>

According to the [[http://dev.w3.org/csswg/selectors3/#w3cselgrammar|Selectors Level 3]] specification: 
   
<file>
Note that pseudo-elements are restricted to one per selector and occur only in the last simple_selector_sequence.
</file>

which seems to prevent the combination of a '::before' pseudo-element selector with another '::in-region()' pseudo selector. 

  * Should we use the pseudo-element syntax for setting style?

This has been discussed before, for example in the following [[http://lists.w3.org/Archives/Public/www-style/2012Jan/0626.html|thread]]. 
In light of the above, it seems to be a better syntax than the @region style rule:

<code>
h2::in-region(regionA) {
   color: red;
}
</code>
