==== Region Styling ====

With regions, element (or pseudo-element) boxes are often broken into multiple pieces that are laid out in different regions. 
For example, it is possible to move an element and its generated box with width:100% to a flow and 
layout the flow between two regions, one of width 500px and one of width 200px. In that situation,
the specified width for the element is 100% and its used value for the portion laid out in the first 
region is 500px and 200px for the second region.

So there is a notion of per-fragment used style.

In addition, regions have a notion of style that applies only to the fragments of an element that
falls into a particular region. A way to think about this is to consider that the selectors in the 
@region style rules apply to the pseudo-elements representing the fragment of the element that falls in
a particular region.

For example:

<code>
@region regionA {
    h2 {
        color: red;
    }
}
</code>

can be interpreted as specifying an additional property for the <code>h2::in-region(regionA)</code> pseudo-element.

If we follow that model, the used style for the content falling into a particular region could be retrieved as:

<code>
window.getComputedStyle(elem, '::in-region(regionA)');
</code>

===== Open questions =====

  * Can we chain pseudo-elements? For example, can we do the following:

<code>
window.getComputedStyle(elem, "::before::in-region(regionA)");
</code>

==== Flowed content boxes and DOM access ====

The DOM specification provides a [[http://www.w3.org/TR/cssom-view/#the-getclientrects-and-getboundingclientrect-methods|way]] 
to compute the bounding client rectangle for an element (<code>getBoundingClientRect()</code>) and its generated 
boxes (<code>getClientRects</code>). The current definition seems appropriate for CSS regions and the multiple boxes generated
for an element flowing through multiple regions. The <code>getClientRects</code> method would return the list of boxes for the 
element found in the different regions. The <code>getBoundingClientRect</code> would work as specified.

The <code>offsetWidth/offsetHeight/offsetTop/offsetLeft</code> attributes would work as specified, using the first box, i.e., the
first part of the element flowing in a region. The usefulness of that is limited, but it is the same situation as for elements
flowing in a multi-column.

The <code>clientTop/clientLeft/clientWidth/clientHeight</code> attributes are relative to the padding edge of the element. For
an element fragmented accross region, the padding edge would be made of the outermost edges, for all the element's fragment boxes. 
However, this does not seem to be the way implementations work for multi-column content, where the WebKit and Opera browsers 
report the edges of the element as if it was laid out in a single column (i.e., as if it appended all the fragments in the 
box direction), Firefox reports the edges of the first fragment's box.
