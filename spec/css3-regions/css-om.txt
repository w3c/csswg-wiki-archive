==== CSS Object Model for CSS Regions ====

=== getFlowByName when there is no flow ===

See https://www.w3.org/Bugs/Public/show_bug.cgi?id=14948

=== naming update on NamedFlow members ===

See https://www.w3.org/Bugs/Public/show_bug.cgi?id=15879

=== attach events to NamedFlow ===

See https://www.w3.org/Bugs/Public/show_bug.cgi?id=15938

=== Disallow flow-into on pseudo-elements to preserve NamedFlow.getContentNodes() ===

See https://www.w3.org/Bugs/Public/show_bug.cgi?id=16383

=== Rename Region.regionOverflow to Region.flowedContent ===

The current 'regionOverlfow' name can be confusing and misunderstood for normal CSS layout overflow
where it actually describes how the named flow content is consumed by the region. The proposal is
to rename the 'regionOverflow' property to 'flowConsumed' with the following values:

  * some: the region consumes some of the flow content, but not all. There is more content left in the named flow.
  * remainder: the region consumes the remainder of the flow content.
  * empty: the region does not consume any of the flow content, but there is more flow content left.
  * none: the region does not consume any flow content because all content has been fitted in previous regions.

The 'empty' value may be superfluous since it is possible to know if a region has no content range (with the getFlowContentRanges).
Therefore, we might just use the some/remainder/node values and allow some to cover both cases described above.

=== Access to flow content (suggested CSS OM Changes) ===

Changes proposed here follow the [[http://lists.w3.org/Archives/Public/www-style/2012Feb/1354.html|discussion]] on the mailing list.
They also address the following bugs:
  *  [[https://www.w3.org/Bugs/Public/show_bug.cgi?id=16286|Issue 16286: NamedFlow should return a static node list]]
 
Note that the following changes use the WebIDL [[http://www.w3.org/TR/WebIDL/#es-sequence|sequence<T>]] type which maps to 
a native JavaScript Array instance. All methods that return a sequence<T> return a new instance on each call.

== Region interface ==

This would replace the supplemental Element interface:

<code>
interface Region {
    readonly attribute DOMString flowConsumed;
    sequence<Range> getRegionFlowRanges();
};              
</code>

== NamedFlow interface changes ==

Changes:
  - Ordered List ItemThe getRegionsByContentNode method now returns a static array of Regions, not a live NodeList.
  - The contentNodes attribute now returns a static list of nodes. Should this be changed to 'getContentNodes()' to make this more obvious to the user?
  - Added a getRegions method to get the current list of regions which are associated with the NamedFlow.

<code>
interface NamedFlow {
  readonly attribute DOMString name;
  readonly attribute boolean overflow;
  
  sequence<Region> getRegions();
  sequence<Node> getContentNodes();
  sequence<Region> getRegionsByContentNode(Node node);
};
</code>

=== Flowed content boxes and DOM access ===

== getClientRects and getBoundingClientRects ==

The DOM specification provides a [[http://www.w3.org/TR/cssom-view/#the-getclientrects-and-getboundingclientrect-methods|way]] 
to compute the bounding client rectangle for an element (getBoundingClientRect()) and its generated 
boxes (getClientRects). 

The current definition seems appropriate for CSS regions and the multiple boxes generated
for an element flowing through multiple regions. The getClientRects method would return the list of boxes for the 
element found in the different regions. The getBoundingClientRect method would work as specified.

== offsetWidth/offsetHeight/offsetTop/offsetLeft ==

The offsetWidth/offsetHeight/offsetTop/offsetLeft attributes would work as specified, using the first box, i.e., the
first part of the element flowing in a region. The usefulness of that is limited, but it is the same situation as for elements
flowing in a multi-column.

The clientTop/clientLeft/clientWidth/clientHeight attributes are relative to the padding edge of the element. For
an element fragmented accross region, the padding edge would be made of the outermost edges, for all the element's fragment boxes. 
However, this does not seem to be the way implementations work for multi-column content, where the WebKit and Opera browsers 
report the edges of the element as if it was laid out in a single column (i.e., as if it appended all the fragments in the 
box direction), Firefox reports the edges of the first fragment's box.