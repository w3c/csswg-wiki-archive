==== Regions: Processing Model for height:auto ====

This page documents a possible processing model for enabling height:auto on regions. 
This is a work in progress and meant to help discussion and drive to an agreed upon model.

=== Multi-Step processing model ===

The model for regions is to layout in at most two steps. Each step has two phases (conceptually):

  * Phase 1. Region layout. In this step, regions are laid out according to the normal CSS box model. No content is flowed into the regions.
  * Phase 2. Flow layout. In this step, content is flowed into the regions laid out in Step 1.

* Step A : Initial Layout *

In all cases, regions are laid out with a first step where regions which have height:auto use an intrinsic height of 0. 

In Step A, if a region has an intrinsic height of 0 and had a specified height of auto, then the user agent does the following:

  - compute the fragment of the flow that would fit in the region (i.e., following the fragmentation rules defined in CSS3 Fragmentation)
  - compute the intrinsic height of the region based on the region's width and the fragment content.
  - freeze the computed intrinsic height for the region.

At the end of Step A, if any region had height:auto, a new two-phase step happens (Step B) where the region layout happens 
and uses the intrinsic heights computed in Step A. Then, the flow layout happens with the regions as positioned and sized in 
phase 1 of Step B.

=== Optimizations ===

Even though the model contains up to two steps with two phases each, implementations can typically optimize 
this model and implement the layout in fewer iterations.

=== Examples ====

== Example A ==

<code>
<style>
#article {
    flow-into: article;
}

#regionA {
     width: 300ex;
     height: auto;
     flow-from: article;
}

</style>

<div id="article">…</div>
<div id="regionA"></div>
</code>

  - Step A, Phase 1: layout regionA. regionA uses an intrinsic size of zero.
  - Step A, Phase 2: layout content in regions. When laying out regionA, because it has height:auto: 
                      - compute the fragment that fits into the region (following fragmentation rules). 
                      - compute the intrinsic height of the region based on the fragment content
                      - freeze the intrinsic height ('Y') for regionB.
                      
Because there is a region with height:auto, a Step B is necessary. 

  - Step B, Phase 1: layout regionA. regionA uses an intrinsic height of 'Y'. 
  - Step B, Phase 2: layout content in region. 
          
== Example B - Edge Case B (from https://www.w3.org/Style/CSS/Tracker/actions/351) ==

<code>
   <div style="display:flexbox">
      <div id="region1" style="flow-from:x; flex:2"></div>
      <div id="region2" style="flow-from:x; flex:1"></div>
   </div>
</code>  

  - Step A, Phase 1: layout region1 and region2 using an intrinsic height of 0. 
  - Step A, Phase 2: layout content in regions. Because region1 has height:auto, 
                      - compute the fragment that fits into the region (following fragmentation rules). 
                      - compute the intrinsic height of the region based on the fragment content
                      - freeze the intrinsic height ('Y') for region1.
     Because region2 has height:auto:
                      - compute the fragment that fits into the region (following fragmentation rules). Depending on what the fragment rules determined fit into region1 there may not be content remaining in the flow.
                      - compute the intrinsic height of the region based on the fragment content
                      - freeze the intrinsic height ('Z') for region2.
                      
Because there is a region with height:auto, a Step B is necessary. 

  - Step B, Phase 1: layout region1 and region2. region1 uses an intrinsic height of 'Y', region2 uses an intrinsic height of 'Z'. 
  - Step B, Phase 2: layout content in region. 
         
== Example C - Edge Case A (from https://www.w3.org/Style/CSS/Tracker/actions/351) ==
<code>
<style>
    #regionA {
        top: 0;
        bottom: 0;
        width: 100px;
        position: absolute;
        flow-from: article;
    }
    
    #regionB {
        flow-from: article;
        width: 200px;
        margin-left: 120px;
        top: 0;
        right: 0;
    }
    
    #article {
        flow-into: article;
    }
    
</style>

<div id="article">…</div>
<div id="container" style="position:relative">
    <div id="regionA"></div>
    <div id="regionB"></div>
</div>
</code>

  - Step A, Phase 1: layout regionA and regionB. regionB uses an intrinsic size of zero and, as a result, regionB's top and bottom compute to 0 and has a height of zero as well.
  - Step A, Phase 2: layout content in regions. When laying out regionB, because regionB has height:auto: 
                      - compute the fragment that fits into the region (following fragmentation rules). 
                      - compute the intrinsic height of the region based on the fragment content
                      - freeze the intrinsic height ('Y') for regionB.
                      
Because there is a region with height:auto, a Step B is necessary. 

  - Step B, Phase 1: layout regionA and regionB. regionB uses an intrinsic height of 'Y'. As a result, 
                     regionA's bottom property's used value is 'Y'.
  - Step B, Phase 2: layout content in region. The content will fit partially in regionA (because it has a narrower width)
                     but will not fill in regionB completely.
                     
                     
== Example D: Multi-column region with height:auto ==

<code>
<style>
#article {
   flow-into: article;
}

#regionA, #regionB {
   flow-from: article;
}

#regionA {
   height: auto;
   column-count: 2;
}

#regionB {
   height: auto;
   column-count: 2;
}
</style>

<div id="article">...</div>
<div id="regionA"></div>
<div id="regionB"></div>
</code>

  - Step A, Phase 1: layout regionA and regionB. Both use an intrinsic height of zero.
  - Step A, Phase 2: layout content in regions. When layout region A, because region A has height:auto:
                        - compute the fragment that fits into the region (following fragmentation rules).
                        - compute the intrinsic height of the region based on the fragment content
                        - freeze the intrinsic height ('Y') for region A.
                      layout content in regionB as well, and because region B has height:auto
                        - compute the fragment that fits into the region,
                        - compute the intrinsic height of the region based on the fragment content
                        - freeze the intrinsic height ('Z') for region B.


  - Step B, Phase 1: layout regionA and regionB using the intrinsic heights of 'Y' and 'Z' respectively.
  - Step B, Phase 2: layout content in regionA and B.
                      