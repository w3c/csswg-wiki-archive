<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Interpolation Timelines - CSS Working Group Wiki (Archive)</title>
<style>
*, *::before, *::after { box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  max-width: 900px; margin: 0 auto; padding: 1.5em 1em; line-height: 1.6;
  color: #1f2328; background: #fff;
}
.archive-banner {
  background: #fff8c5; border: 1px solid #d4a72c; border-radius: 6px;
  padding: 0.75em 1em; margin-bottom: 1.5em; font-size: 0.9em;
}
.archive-banner strong { color: #6e5600; }
header { border-bottom: 1px solid #d1d5db; padding-bottom: 1em; margin-bottom: 1.5em; }
header h1 { margin: 0; font-size: 1.25em; }
header h1 a { color: #0366d6; text-decoration: none; }
header h1 a:hover { text-decoration: underline; }
nav { margin-top: 0.5em; font-size: 0.9em; }
nav a { color: #656d76; text-decoration: none; margin-right: 1em; }
nav a:hover { color: #0366d6; }
h1, h2, h3, h4 { color: #1f2328; margin-top: 1.5em; }
h1:first-child { margin-top: 0; }
a { color: #0366d6; }
code { background: #f6f8fa; padding: 0.15em 0.3em; border-radius: 3px; font-size: 0.9em; }
pre { background: #f6f8fa; padding: 1em; overflow: auto; border-radius: 6px; }
pre code { background: none; padding: 0; }
table { border-collapse: collapse; margin: 1em 0; }
th, td { border: 1px solid #d1d5db; padding: 0.4em 0.8em; }
th { background: #f6f8fa; }
img { max-width: 100%; }
.breadcrumb { font-size: 0.85em; color: #656d76; margin-bottom: 1em; }
.breadcrumb a { color: #656d76; }
ul, ol { padding-left: 1.5em; }
li { margin: 0.25em 0; }
.plugin_note { background: #f0f4f8; border-left: 4px solid #0366d6; padding: 0.75em 1em; margin: 1em 0; border-radius: 3px; }
abbr { text-decoration: underline dotted; cursor: help; }
@media (prefers-color-scheme: dark) {
  body { background: #0d1117; color: #e6edf3; }
  .archive-banner { background: #3d2e00; border-color: #6e5600; }
  .archive-banner strong { color: #f0c000; }
  header { border-bottom-color: #30363d; }
  header h1 a { color: #58a6ff; }
  nav a { color: #8b949e; }
  nav a:hover { color: #58a6ff; }
  h1, h2, h3, h4 { color: #e6edf3; }
  a { color: #58a6ff; }
  code, pre { background: #161b22; }
  th, td { border-color: #30363d; }
  th { background: #161b22; }
  .breadcrumb, .breadcrumb a { color: #8b949e; }
  .plugin_note { background: #161b22; border-color: #58a6ff; }
}
</style>
</head>
<body>
<div class="archive-banner">
<strong>Archive Notice:</strong> This is a read-only archive of the CSS Working Group Wiki.
The original wiki was hosted at wiki.csswg.org.
</div>
<header>
<h1><a href="/">CSS Working Group Wiki</a></h1>
<nav>
<a href="/">Home</a>
<a href="/spec/">Specs</a>
<a href="/ideas/">Ideas</a>
<a href="/test/">Testing</a>
<a href="/wiki/">About</a>
</nav>
</header>
<div class="breadcrumb"><a href="/">Home</a> / <a href="/ideas/">ideas</a> / timelines</div>
<main>
<!-- TOC START -->
<div id="dw__toc" class="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><a href="#interpolation-timelines">Interpolation Timelines</a><ul class="toc">
<li class="level2"><a href="#time-linked-animations">Time-linked Animations</a></li>
<li class="level2"><a href="#scroll-linked-animations">Scroll-linked Animations</a><ul class="toc">
<li class="level3"><a href="#animations-linked-to-scroll-progress-as-timeline">Animations linked to scroll progress as timeline</a></li>
<li class="level3"><a href="#animations-linked-to-view-progress-as-timeline">Animations linked to view progress as timeline</a></li>
<li class="level3"><a href="#scope-of-scroll-linked-timelines">Scope of Scroll-linked Timelines</a></li>
</ul>
</li>
<li class="level2"><a href="#query-linked-timelines">Query-linked Timelines</a><ul class="toc">
<li class="level3"><a href="#defining-the-query-timeline">Defining the Query Timeline</a></li>
<li class="level3"><a href="#value-interpolation">Value Interpolation</a></li>
</ul>
</li>
<li class="level2"><a href="#scroll-triggered-animations">Scroll-triggered Animations</a></li>
<li class="level2"><a href="#appendixminor-details">Appendix: Minor Details</a></li>
</ul></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 id="interpolation-timelines">Interpolation Timelines</h1>
<p>
This page explores some ideas about integrating animations, interpolation, and timelines.
</p>
<div class="plugin_note noteimportant">These ideas have been drafted into and superseded by <a href="https://www.w3.org/TR/css-animations-2/" title="https://www.w3.org/TR/css-animations-2/" rel="noopener">CSS Animations Level 2</a>, <a href="https://www.w3.org/TR/scroll-animations/" title="https://www.w3.org/TR/scroll-animations/" rel="noopener">Scroll Animations Level 1</a>, and <a href="https://www.w3.org/TR/css-values-5/" title="https://www.w3.org/TR/css-values-5/" rel="noopener">CSS Values Level 5</a>
</div><h2 id="time-linked-animations">Time-linked Animations</h2>
<p>
These are the classic form of <a href="https://www.w3.org/TR/css-animations-1/" title="https://www.w3.org/TR/css-animations-1/" rel="noopener">CSS animations</a>, linked to a time-based timeline.
</p>
<ul>
<li class="level1"><strong>animation-name</strong> - names set of keyframes to use (which are defined using @keyframes)</li>
<li class="level1"><strong>animation-duration</strong> - sets duration of animation (assigns 0%-100% to the start/end of the given duration)</li>
<li class="level1"><strong>animation-timing-function</strong> - easing function between keyframes</li>
<li class="level1"><strong>animation-delay</strong> - delays start of first keyframe</li>
</ul><h2 id="scroll-linked-animations">Scroll-linked Animations</h2>
<p>
Scroll-linked animations use a timeline based on scroll position, rather than one based on actual time. This proposal is based off of the current <a href="https://drafts.csswg.org/scroll-animations-1/" title="https://drafts.csswg.org/scroll-animations-1/" rel="noopener">Scroll-linked Animations ED</a>, but shifts away from the more fragile explicit calculations to implicit offsets based on element positions and local context. (The logic is similar to how our latest scroll-snap <abbr title="specification">spec</abbr> shifted its approach compared to the original Microsoft <abbr title="specification">spec</abbr>.)
</p><h3 id="animations-linked-to-scroll-progress-as-timeline">Animations linked to scroll progress as timeline</h3>
<p>
These are animations whose timeline goes from 0% to 100% based on the scroll position of an ancestor scroll container. Proposal is to use an inline functional notation to identify the timeline using the <code>animation-timeline</code> property.
</p>
<pre class="code">animation-timeline: auto | scroll(DIRECTION? SCROLLERNAME?);
DIRECTION = block | inline | vertical | horizontal
SCROLLERNAME = root | nearest | IDENT</pre>

<p>
<strong>nearest</strong> (the default) references the nearest ancestor scroll container; <strong>root</strong> references the main viewport scroller. IDENT references the <code>container-name</code> property: it filters the lookup to the nearest scroll container with the given <code>container-name</code>. The default direction is <code>block</code>.
</p>

<p>
(<code>auto</code> is the initial value, and behaves as animations have always done, triggering on application of the animation and lasting for the specified duration and delay.)
</p>

<p>
Alternately, some <code>scroll-timeline</code> properties could be defined, which when used on a scroll container would allow naming its timeline for a more indirect but reusable approach.
</p>
<pre class="code">scroll-timeline-name: IDENT#;
scroll-timeline-direction: DIRECTION#;
scroll-timeline: [DIRECTION? IDENT]#;</pre><h3 id="animations-linked-to-view-progress-as-timeline">Animations linked to view progress as timeline</h3>
<p>
Often animations are desired to start and end while a particular element is in view within the scroller. This timeline is essentially a snippet of the scroller&#039;s complete timeline, with 0% and 100% pinned to the moment the element comes into view and the moment it leaves view.
</p>
<ul>
<li class="level1"><strong><code>view-timeline-name = IDENT</code></strong> - Specifies a name for this element&#039;s in-view timeline, so that it can be referenced by descendant and sibling elements as their <code>animation-timeline</code>.</li>
<li class="level1"><strong><code>view-timeline-inset = [ auto | LENGTH-PERCENTAGE ]{1,4}</code></strong> - Specifies an inset (positive) or outset (negative) adjustment of the scrollport when considering whether the element is in view. <code>auto</code> indicates to use the value of <code>scroll-padding</code>. Initial value is zero. Percentages are with reference to the scrollport.</li>
<li class="level1"><strong><code>view-timeline-fit = [ cover | contain | PERCENTAGE ]</code></strong> - Specifies whether the in-view timeline is measured from the moment any part of the box comes into view until all parts leave it (<code>cover</code>/<code>0%</code>) or whether it is measured from the moment all parts of the box come into view until any part leaves it (<code>contain</code>/<code>100%</code>). Initial value is 100% (<code>cover</code>).</li>
</ul><h3 id="scope-of-scroll-linked-timelines">Scope of Scroll-linked Timelines</h3>
<p>
The scope of a scroll-linked timeline (which elements can call it by name via <code>animation-timeline</code>) is defined as:
* its descendants
* its siblings (and their descendants)
</p>

<p>
This basically means its scope is attached to its parent, but the parent can&#039;t use it. In case of multiple timelines with the same name being in scope, the timeline associated with its nearest ancestor wins.
</p>

<p>
(It might also be useful to allow the scope to expand outside this parent, giving ancestors and far cousins access to the timeline across the document. In all cases the timeline reached via the closest ancestor should win in case of conflict. But this kind of global scoping from descendant elements might be difficult to implement.)
</p><h2 id="query-linked-timelines">Query-linked Timelines</h2>
<p>
Query-linked interpolation uses a set of keyframes (minimally, two) to interpolate values along an easing curve based on the value of a query (such as a media query or container query). The timeline is therefore defined by the value of the query, and can be referenced by an interpolation function in individual property declarations.
</p><h3 id="defining-the-query-timeline">Defining the Query Timeline</h3>
<p>
The <code>@timeline</code> rule defines a named timeline. It can be expanded later to define other types of timelines, but here we&#039;re defining only two types: media query timelines and container query timelines.
</p>
<pre class="code">@timeline NAME {
  type: media | container;
  feature: &lt;media-feature-name&gt; | &lt;container-feature-name&gt;;
  from: &lt;value&gt;; /* 0% of the timeline */
  to: &lt;value&gt;; /* 100% of the timeline */
  container: &lt;&#039;container&#039;&gt;; /* only applies to container query timelines,
                               same seeking function as container queries */
}</pre>

<p>
A typical example might look like:
</p>
<pre class="code">@timeline font-size-timeline {
  type: media;
  feature: width;
  from: 20em;
  to: 60em;
}</pre>

<p>
Query-linked timelines are allowed by naming them in <code>animation-timeline</code>, but it&#039;s not recommended to use this method in most cases because it would cause cascading problemsâ€”where anyone using query-based interpolation via animation properties would override all affected properties at levels of the cascade. They can instead be referenced by an interpolation function within the affected property declarations, which allows the interpolated value to cascade the same as any other declared value.
</p><h3 id="value-interpolation">Value Interpolation</h3>
<p>
Value interpolation uses a percentage value to indicate how close or far from the start/end points to calculate the interpolated value. Interpolation is interpreted through an easing curve, and the input percentage can be selected based on the current position on a timeline such as a query timeline.
</p><h4 id="basic-generic-value-interpolation">Basic Generic Value Interpolation</h4>
<p>
[See <a href="https://github.com/w3c/csswg-drafts/issues/581" title="https://github.com/w3c/csswg-drafts/issues/581" rel="noopener">Native interpolation function in CSS</a> issue.]
</p>
<pre class="code">  mix( [ PERCENT &amp;&amp; [ by EASING ]? ] ; STARTVALUE ; ENDVALUE)</pre>

<p>
PERCENT represents the percent of progress between STARTVALUE and ENDVALUE, and EASE is used to calculate the mix ratio represented by that amount of progress. The default easing function is linear.
</p>
<pre class="code">  opacity: mix( 70% by ease ; 0% ; 100% )</pre>

<p>
Note: The generic <code>mix()</code> function needs to use semicolons instead of commas, because commas can be part of the value space of various properties. (Since one key use case for the generic interpolation function is used to represent intermediate states in the OM, it has to be able to represent the interpolation of any two values on any two properties.)
</p><h4 id="timeline-based-value-interpolation">Timeline-based Value Interpolation</h4>
<p>
[See <a href="https://github.com/w3c/csswg-drafts/issues/6245" title="https://github.com/w3c/csswg-drafts/issues/6245" rel="noopener">Interpolate values between breakpoints</a> issue.]
</p>
<pre class="code">  mix( [ TIMELINE &amp;&amp; [ by EASE ]? ] ; STARTVALUE ; ENDVALUE)</pre>

<p>
By naming a timeline instead of giving a percentage directly, the author can use progress along a timeline as the progress percentage. Any value valid for <code>animation-timeline</code> or any timeline name defined via <code>@timeline</code> is valid, which allows the mix() to respond to query-linked timelines and scroll-linked timelines.
</p><h4 id="value-interpolation-with-keyframes">Value Interpolation with Keyframes</h4>
<p>
For more complex interpolation curves, the STARTVALUE and ENDVALUE can be replaced by a reference to a named set of keyframes.
</p>
<pre class="code">  mix( [ TIMELINE &amp;&amp; [ by EASE ]? &amp;&amp; of KEYFRAMES ] )</pre>

<p>
Note: Using keyword markers (as in gradients) allows the arguments to be reordered, so that authors don&#039;t have to memorize positions of arguments.
</p><h2 id="scroll-triggered-animations">Scroll-triggered Animations</h2>
<p>
Scroll-triggered animations are started or ended based on scroll positions, but their progress through animation is linked to time. This is distinct from scroll-linked animations, in which progress through animation is linked to the scroll position and has no relation to time.
</p>

<p>
<a href="https://birtles.github.io/scroll-animations-triggers/#scroll-triggered-animations-usecases" title="https://birtles.github.io/scroll-animations-triggers/#scroll-triggered-animations-usecases" rel="noopener">Brian Birtles proposed</a> using an <strong>animation-trigger</strong> property to specify when to trigger the start of a time-based animation timeline. The default (current) behavior is to trigger when the element the animation property is applied, but new values would allow triggering when it is scrolled or snapped into view. There might be some possibilities for simplifying it by using snap positions or view timeline start/end points as triggers.
</p><h2 id="appendixminor-details">Appendix: Minor Details</h2>
<p>
Some details we need to make sure to <abbr title="specification">spec</abbr> correctly:
</p>
<ul>
<li class="level1">If the timeline has zero length. (Animations currently land on the last keyframe, so probably other timelines should follow this precedent.)</li>
<li class="level1">If <code>view-timeline-fit</code> is 100% but the element is larger than the viewport. (Probably the fit should be clamped by fitting the requested percentage of the element or filling the size of the viewport, whichever is smaller.)</li>
<li class="level1">All timelines share the same namespace.</li>
</ul>
</main>
</body>
</html>
